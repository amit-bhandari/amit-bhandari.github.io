[{"content":"Android Continuous Integration and Delivery, Everyone is talking about it these days. So what exactly it is and why do you need it? Well following article can explain better than me.\nContinuous integration, explained\nIf you are working on Android project with team of 2 or more and pushing and integrating code on daily basis on VCS, you must use Android Continuous Integration to make your life easier with all those build fails, error and basic test executions. Every time someone pushes code, Android Continuous Integration will build and run unit tests automatically on server and notify you of any errors instantly (it will notify you for successful build as well). How cool is that?\nAs a Android developer, most boring thing in world for me is signing apk, going to play console and uploading it. And again there is this task of uploading deobfuscation file of trace logs. Thanks to google, they exposed google play console API for automating that stuff too. Well, wouldn’t it be awesome if you just merge your code in your master, and your Android Continuous Integration server uploads signed apk and deobfuscation file to your play console for you? Off course it will be.\nIf you want to set up this arrangement for your Android project, go on reading the article as I would try to mention all the steps necessary to set up the system, but if I do miss something, do not threaten to kill my family, just ask nicely and I would help you out.\nP.S. This process is not as simple as double click on installer.exe -\u0026gt; next -\u0026gt; next -\u0026gt; finish -\u0026gt; launch, it’s highly likely you may run into shit load of problems (or you may not), but don’t give up and after successful setup, you will thank yourself for life. It took me almost a day to set this up as I was very new to CI thing. If you face any issue, you can always drop comment below and I will try to help you out.\nAndroid Continuous Integration (CI) Jenkins is the name which pops up in head of most people when they hear the phrase CI, it is most used, Java based, open source automation server. But I personally found Team City by JetBrains (yes, same awesome people who came up with Kotlin and Android Studio) much easier to configure and use. Even though Team City is proprietary software with commercial license, they provide Freemium license up to 100 build configurations (which is more than enough for Hobbyist like me). Without wasting any time, let’s get started installing team city in your server. (It can be installed in your computer as well if you are the only person working on project)\nInstallation on Linux For other OS, refer official installation quick start guide\nDownload latest version in tar.gz from official website. Open up terminal, change directory to downloads and issue simple ‘tar xfz TeamCity.tar.gz’ to unzip the content in same directory. To start Team City server, move to TeamCity/bin directory and give ‘runAll.sh start’ command. To stop, give ‘runAll.sh stop’. You could create alias in your bashrc file or mention command in startup program list to automatically start TC server on startup. By default team city runs on 8111 port, so open up a browser and browse to http://localhost:8111/ to set up build configurations. Follow this for first time set up and account creation.\nNow create your first project on Team City by clicking on Administration on top right corner. There are several options provided to create project i.e. from Github, Bitbucket, Repository URL or manual setup. You could setup Github connection in your TC by providing credentials and TC will list all your repositories to choose from.\nAndroid Continuous Integration Setup on Team City[/caption]\nSelect repository you want to setup CI for and click on Proceed.\n//image 2\nAndroid Continuous Integration Setup on Team City[/caption]\nTC will try to auto read build steps for project by going through project files and find the correct one most of the times, if not, you can always provide the build steps manually\n//image 3\nAndroid Continuous Integration Setup on Team City[/caption]\nSelect Gradle and click on use selected. (later we will modify build steps to include auto upload of signed apk to play console)\nBy default, TC will take master branch of repository as default one for setting up VCS trigger for starting build. TC will periodically check for any changes on repository and initiate build as soon as new code is pushed to it. You can customize almost everything in project settings, like default branch, repository checking interval etc.\nI personally like to keep 3 branches in my android project on Git i.e. master (release build), beta (alpha/beta build) and development (where I commit crap on hourly basis). I set up my VCS trigger on ‘beta’ branch so that whenever I push any changes (or merge) to ‘beta’, automatic build and deployment will happen in TC. And I don’t even have to manually upload release.apk and mapping.txt on console.\nTo edit default branch of your project (change VCS trigger to beta branch in my case), go to Project Settings -\u0026gt; VCS Roots -\u0026gt; Edit (on particular VCS root) -\u0026gt; Default branch and update its value.\n//image 4\nAndroid Continuous Integration Setup on Team City //image 5\nAnd your TC is setup to check beta branch every 1 minute and checkout changes (if any) and build the project. You can setup notification system to notify you in case of failure (or success as well) via email. Explore the thing in your TC settings.\nContinuous Delivery (CD) Now comes the exciting part, automatic upload of release apk to alpha/beta/production and mapping.txt to De-obfuscation files in your play console. Google provides play console API for doing this and fortunately (as always), some good people came together to write a library to make it super easy for us to use it in our project without dealing with APIs our self. (If you just had Thumbs Up and want to do something TOOFANI, go ahead and consume those APIs for yourself)\nBefore getting started with Gradle Play Publisher, make sure you provide proper signing info in your gradle file so that it can automatically sign your apk with your key and initiate upload. There are multiple ways you could mention signing info in your gradle file, one being mentioning passwords and key file path directly in gradle file itself, but its extremely insecure and could expose your passwords to anyone having access to code.\nSigning info in Gradle file Best way is to write those details in external file, list that file in your .gitignore and read values from that file in your build.gradle. Create new file at root directory of project and name it keystore.properties and enter this 5 entries in it(with your values). Don’t worry about p12 file yet, I will tell you how to get it shortly.\nstoreFile=/key/file/path.jks keyAlias=key0 storePassword=notasecret keyPassword=notasecret p12keyFile=/path/to/your/p12key/file/Google Play Android Developer-2355232355.p12 And reference this file and values in build.gradle like this.\n// Load keystore def keystorePropertiesFile = rootProject.file(\u0026#34;/path/to/your/keystore.properties\u0026#34;) def keystoreProperties = new Properties() keystoreProperties.load(new FileInputStream(keystorePropertiesFile)) android{ signingConfigs{ release { storeFile file(keystoreProperties[\u0026#39;storeFile\u0026#39;]) storePassword keystoreProperties[\u0026#39;storePassword\u0026#39;] keyAlias keystoreProperties[\u0026#39;keyAlias\u0026#39;] keyPassword keystoreProperties[\u0026#39;keyPassword\u0026#39;] } } buildTypes { release { signingConfig signingConfigs.release ... } } } Source for this info To make sure your signing info is correct and works, choose ‘release’ build variant from ‘Build Variants’ tab on lower left side of Android Studio (if you are using Eclipse, seriously?) and try installing app on device. If no error, good to go. If errors, google is always there to help. (before rushing to google by copying error blindly, read it. Most of the times, error arises because of our stupid mistake)\nEnabling play console API access and getting p12 key file To get started using play console API, we need p12 key file and instructions to link your project and creating service account is nicely documented by google here.\nMain steps are\nGoing to API access page in developer console and linking your project by clicking on link. //image 6 We need to set up API access client by creating service account. You will see option to create service account on the same page below under ‘Service Accounts’ section. //image 7 Click on ‘grant access’ and give required permissions. //image 8 Once your service account is set up, go to Google API Console, open up credentials from left navigation, click on create credentials -\u0026gt; Service account key -\u0026gt; Choose your service account -\u0026gt; Choose P12 and click create. This will download P12 key file in your browser. Do not share this file with anyone.\n//image 9\nOnce you successfully got key file, place it somewhere in your server securely (make sure you don’t include the file in VCS) and mention that path in keystore.properties file. Now mention your service account email and apk upload track (alpha, beta or prod) in build.gradle like this. (Refer documentation for all the options and how to use them)\nplay { track = \u0026#39;alpha\u0026#39; serviceAccountEmail = \u0026#39;ab-***t@api-********************-54989.iam.gserviceaccount.com\u0026#39; pk12File = file(keystoreProperties[\u0026#39;p12keyFile\u0026#39;]) } And sync your project with gradle. To make sure signing info is correctly set up and your build is ready to upload apk to console upon successful build, go to terminal and change working directory to your root android project and give command ‘./gradlew tasks’ and you should be able to see all the available play store tasks (you will not see ‘publishApkRelease’ if there is problem in your signing info in build.gradle)\n//image 10\nYou can test your apk upload task by running ‘./gradlew publishApkRelease’ in terminal right away. It should invoke build and upload release.apk along with the de-obfuscation to your play console.\nSetting up TC to upload your apk I keep my repository organized in 3 branches as discussed earlier. I have set beta branch of my code to invoke build and publishApkRelease on Android Continuous Integration TC server. You could set up your system as per your requirement and liking. All you have to do is mention ‘publishApkRelease’ task in your build steps in TC Project Settings like below.\n//image 11\nNow you can test your Android Continuous Integration setup by pushing test changes on branch (‘beta’ in my case). I hope you don’t face any error which google won’t be able to help with.\nThis article was originally written on medium here\n","permalink":"http://localhost:1313/posts/android-ci-cd/","summary":"Android Continuous Integration and Delivery, Everyone is talking about it these days. So what exactly it is and why do you need it? Well following article can explain better than me.\nContinuous integration, explained\nIf you are working on Android project with team of 2 or more and pushing and integrating code on daily basis on VCS, you must use Android Continuous Integration to make your life easier with all those build fails, error and basic test executions.","title":"Android Continuous Integration and Delivery — Next level Android development"},{"content":"If you are using data binding to bind java pojo to view in Android, you must have came across the issue that you can’t really bind image url in xml directly. Android Image View does not support it by default. But you can easily extend Android Image View to create your own custom view which can support it.\nLets get started.\nFirst of all, to allow your views to pick parameter from xml, resource needs to be declared in attrs.xml in in values resources. Go ahead and create attrs.xml in values directory if it doesn\u0026rsquo;t exists already and add this one parameter in it.\n\u0026lt;declare-styleable name=\u0026#34;MyImageView\u0026#34;\u0026gt; \u0026lt;attr name=\u0026#34;url\u0026#34; format=\u0026#34;string\u0026#34; /\u0026gt; \u0026lt;/declare-styleable\u0026gt; Now create class MyImageView and extend it from ImageView. Example code below in kotlin, but java counterpart will be pretty much same.\nclass MyImageView : ImageView { var url: String = \u0026#34;\u0026#34; set(value){ field = value Glide.with(this).load(value).into(this) } constructor(context: Context) : super(context) constructor(context: Context, attrs : AttributeSet) : super(context,attrs){ val array = context.obtainStyledAttributes(attrs, R.styleable.MyImageView) val url = array.getString(R.styleable.MyImageView_url) if(url!=null){ Glide.with(this).load(url).into(this) } array.recycle() } constructor(context: Context, attrs: AttributeSet , defStyleAttr : Int) : super(context, attrs, defStyleAttr) } As noticed in constructor, we are picking up url from xml if provided and setting it as source using Glide. You can use any third party library you want for that matter.\nNow you can use our created custom image view in xml like this.\n\u0026lt;our.package.path.MyImageView android:id=\u0026#34;@+id/image_view\u0026#34; android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; app:url=\u0026#34;https://www.famouslogos.net/images/android-logo.jpg\u0026#34;/\u0026gt; As you can see how easily we can now set url directly from xml for our image view. But hardcoding url like this is not useful at all and we can use data binding to bind variable directly to url of image view.\nIf you have no idea what data binding is, I suggest you to go through this and this. It is awesome by the way.\nNow our xml looks like this where pojo is your pojo variable name.\n\u0026lt;our.package.path.MyImageView android:id=\u0026#34;@+id/image_view\u0026#34; android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; app:url=\u0026#34;@{pojo.invoiceLogoLink}\u0026#34;/\u0026gt; If you are wondering how we manage the scenario where this parameter is changes at runtime, you can see setter for url variable like this in kotlin class,\nvar url: String = \u0026#34;\u0026#34; set(value){ field = value Glide.with(this).load(value).into(this) } Every time value changes in pojo, setter is invoked and we change the image using Glide.\nClap if you like what you read.\nThis article was originally written on medium here\n","permalink":"http://localhost:1313/posts/image-view-extension/","summary":"If you are using data binding to bind java pojo to view in Android, you must have came across the issue that you can’t really bind image url in xml directly. Android Image View does not support it by default. But you can easily extend Android Image View to create your own custom view which can support it.\nLets get started.\nFirst of all, to allow your views to pick parameter from xml, resource needs to be declared in attrs.","title":"Extend Image View to allow URL binding in xml directly"},{"content":"Room is a persistence library introduce by Google in this year I/0. Room makes it extremely easy to work with SQLite in your android application and worth giving a shot if you are using SQLiteOpenHelper as of now for handling data in your app. Migrating your current implementation to Room is, surprisingly, very easy. Google has provided samples for this here, but I personally think it’s too much code for such simple task and it can be explained easily. I explain below few simple steps for migrating your current implementation to Room DB and I hope you will find it helpful, if you do, share it and let other people know about it.\nSQLiteOpenHelper implementation: SQLiteOpenHelper is a helper class which manages database creation and version management. All the CRUD operations of database we have to implement by sub classing SQLiteOpenHelper. You can find more info about how it is done here. We will migrate user database currently implemented using SQLiteOpenHelper. Current implementation looks like this.\npublic class User { private int uId; private String uName; private String uContact; public User() { } public User(int id, String name, String number){ this.uId = id; this.uName = name; this.uContact= number; }; //getters setters left out for brevity } All the users we have to store in SQLite db and for that we will use helper class UserDbHelper sub classed from SQLiteOpenHelper.\npublic class UserDbHelper extends SQLiteOpenHelper { private static final int DATABASE_VERSION = 1; // Database Name private static final String DATABASE_NAME = \u0026#34;userDB\u0026#34;; // user table name private static final String TABLE_USERS = \u0026#34;users\u0026#34;; // user Table Columns names private static final String USER_ID = \u0026#34;user_id\u0026#34;; private static final String USER_NAME = \u0026#34;user_name\u0026#34;; private static final String USER_PH_NO = \u0026#34;user_contact\u0026#34;; public UserDbHelper(Context context) { super(context, DATABASE_NAME, null, DATABASE_VERSION); } @Override public void onCreate(SQLiteDatabase db) { //create the table if not yet created String CREATE_USER_TABLE = \u0026#34;CREATE TABLE \u0026#34; + TABLE_USERS + \u0026#34;(\u0026#34; + USER_ID + \u0026#34; INTEGER PRIMARY KEY,\u0026#34; + USER_NAME + \u0026#34; TEXT,\u0026#34; + USER_PH_NO + \u0026#34; TEXT\u0026#34; + \u0026#34;)\u0026#34;; db.execSQL(CREATE_USER_TABLE); } @Override public void onUpgrade(SQLiteDatabase db, int i, int i1) { // Drop older table if existed db.execSQL(\u0026#34;DROP TABLE IF EXISTS \u0026#34; + TABLE_USERS); // Create tables again onCreate(db); } public void addUser(User user){ //Add new user to database SQLiteDatabase db = this.getWritableDatabase(); ContentValues values = new ContentValues(); values.put(USER_NAME, user.getUName()); // Contact Name values.put(USER_PH_NO, user.getUContact()); // Contact Phone values.put(USER_ID, user.getUId()); // Inserting Row db.insert(TABLE_USERS, null, values); db.close(); // Closing database connection } public User getUser(int id){ SQLiteDatabase db = this.getReadableDatabase(); Cursor cursor = db.query(TABLE_USERS, new String[] { USER_ID, USER_NAME, USER_PH_NO }, USER_ID + \u0026#34;=?\u0026#34;, new String[] { String.valueOf(id) }, null, null, null, null); if (cursor != null) cursor.moveToFirst(); User contact = new User(Integer.parseInt(cursor.getString(0)), cursor.getString(1), cursor.getString(2)); return contact; } } Now we can add users to database like this.\n//get database instance UserDbHelper userDbHelper = new UserDbHelper(this); //add couple of users userDbHelper.addUser(new User(1,\u0026#34;Hulk\u0026#34;,\u0026#34;11-445-9999\u0026#34;)); userDbHelper.addUser(new User(2,\u0026#34;Dominic\u0026#34;,\u0026#34;11-445-9999\u0026#34;)); And fetch the users using this. User extractedUser = userDbHelper.getUser(1);\nAs you can see, we have to write queries to put and fetch data in table ourselves using ContentValues and cursors. This kind of code is highly prone to errors and errors can be difficult to find as well. Also there is not compile time check involved in above implementation which can produce potential runtime errors and termination.\nRoom helps you achieve database abstraction through Data Access Objects and also provides compile time query checks so as to minimize potential runtime failures. Win win for developers!\nMigrating to Room: I assume that at this point, you know the basics of how Room works and have tried it out. If not, I would recommend you go through this tutorial to get started. For migrating our current implementation of users database, we will update our POJO class first. Lets add @Entity annotations to User class as this class will be mapped to table in our database. It is mandatory to define at least one primary field in Room.\n@Entity public class User { @PrimaryKey private int uId; private String uName; private String uNumber; public User() { } @Ignore public User(int id, String name, String number){ this.uId = id; this.uName = name; this.uNumber= number; }; //add all the getters and setters here } Let’s create Data Access Object (DAO) for exposing methods which will be used by application for accessing the data back and forth from database. Our DAO implementation will be very easy, it will only be 2 method, one to add user to database and one to read all users from database.\n@Dao public interface UserDAO { @Insert(onConflict = REPLACE) void insertUser(User user); @Query(\u0026#34;SELECT * FROM User\u0026#34;) List\u0026lt;User\u0026gt; getUsers(); } As you can see above, how simple implementation we provided for Data Access Object. Compare it with the methods we used in SQLiteOpenHelper class for carrying out same operations. For adding, updating or deleting row(s) in table, we don’t even have to form queries, Room will do it for us. Only for reading data, we need to use @Query annotation and provide it with query unlike SQLiteHelper where we have to deal with cursors and all of boiler plate code. Remember, more the code, more the bugs!\nWe will get DAO object instance from RoomDatabase class. RoomDatabase class will be the abstract class with only one method as shown below. We have to mention version number for DB in this class. As we are migrating Database from SQLiteHelper to Room, version number needs to be more than SQLiteHelper db version number. We have used version 1 for our SQLiteHelper Database, so we will user version 2 for Room.\n@Database (entities = {User.class},version = 2) public abstract class UserDB extends RoomDatabase { public abstract UserDAO userDAO(); } And we are done with our Room Database implementation and its time to see it in action. While creating RoomDatabase, we have to provide migration information which we will see in next part.\nWe need Migration class instance while building Room Database from database builder. Migration class constructor takes 2 versions as parameter, one is the version from which it needs to migrate (version 1 in our case) and second is the version to which it is going to migrate (version 2 in our case). It provides one method migrate(SupportSQLiteDatabase db). SupportSQLiteDatabase which is called by Room while migrating the Database with db instance as parameter. Here is the place where we can make changes (if any) to db schema or db data. If we do not want to make any changes, and just want to migrate, we leave the implementation empty. This is how we create Room Database.\nfinal Migration MIGRATION_1_2 = new Migration(1, 2) { @Override public void migrate(SupportSQLiteDatabase database) { // Since we didn\u0026#39;t alter the table, there\u0026#39;s nothing else to do here. } }; //create db final UserDB userDB = Room.databaseBuilder(this , UserDB.class , \u0026#34;userDB\u0026#34;) .addMigrations(MIGRATION_1_2) .build(); //inserting and accessing data using DAO //this operations needs to be performed on thread other than main thread userDB.userDAO().insertUser(new User123(5,\u0026#34;Wowman\u0026#34;, \u0026#34;888888888\u0026#34;)); userDB.userDAO().insertUser(new User123(6,\u0026#34;Captain\u0026#34;, \u0026#34;888888888\u0026#34;)); User user = userDB.userDAO().getUsers().get(0); And that is pretty much it. We are done with our changes and executing this will migrate our db successfully to room.\nYou can get the source code mentioned here on my Github here.\nBut while migrating db, you need to make sure of couple things, otherwise you may face issues.\nYou have to make sure column names mentioned in SQLiteHelper class and your POJO class should match, otherwise migration will not be successful. For e.g. suppose column name for id field of user is ‘user_id’ in SQLite open helper class, either you have to name your id variable in POJO class ‘user_id’ or explicitly mention column name of id field by using @ColumnInfo annotation like this @ColumnInfoname(name=\u0026#34;user_id\u0026#34;) private int uId; You have to make sure that table names also matches. By default, room will assign table name as name of entity class (‘user’ in our case), but we can change this by mentioning table name while annotating entity class like this @Entity( tableName = “users” ) This article was originally written on medium here\n","permalink":"http://localhost:1313/posts/sqlite-room-migration/","summary":"Room is a persistence library introduce by Google in this year I/0. Room makes it extremely easy to work with SQLite in your android application and worth giving a shot if you are using SQLiteOpenHelper as of now for handling data in your app. Migrating your current implementation to Room is, surprisingly, very easy. Google has provided samples for this here, but I personally think it’s too much code for such simple task and it can be explained easily.","title":"Migrating existing SQLite implementation to Room"},{"content":"If you have been following Architectural components introduced in I/0 2017, you must already be familiar with the Room Persistence Library which provides you abstraction layer over SQLite to provide smooth database access and using SQLite with full potential. If you are not aware or don’t know how Room Database works, I would recommend reading this article which shows the very basic usage and implementation of Room Database in your android project.\nBy default, POJO class (called entity in Room DB) can have only primitive java data types which will be saved in respective columns by Room DB. Most of the time, this is not a problem because POJO classes generally have only primitive data fields. You can also use embedded tag to store object as nested columns in Room Database. But sometimes, we may need to store object as is in one column, so Type Converters comes to the rescue. If you do not use TypeConverter, you will come across this error.\nerror: Cannot figure out how to save this field into database.\nYou can consider adding a type converter for it.\nWe will see how easily we can use Type Converter to store any object in Room by quickly modifying the User POJO from Googles official documentation to include one more field of ArrayList. Suppose we are storing database of users and you want to include their pet names as well while saving, you are gonna need ArrayList to save it (You don’t want your first dog to get bored while you go to work or read this, do you?)\nBefore we get started, put this dependencies in your gradle build file.\ncompile \u0026#34;android.arch.persistence.room:runtime:1.0.0-alpha3\u0026#34; annotationProcessor \u0026#34;android.arch.persistence.room:compiler:1.0.0-alpha3\u0026#34; compile \u0026#39;com.google.code.gson:gson:2.6.2\u0026#39; First 2 lines for including Room DB in our project and 3rd one is Gson which we will use to convert our object to String.\nOur modified User.java looks something like this. Even though you can’t see any getter or setter method here, you need to include them or make the fields public for Room to access it.\n@Entity public class User { @PrimaryKey private int uId; private String uName; private ArrayList\u0026lt;String\u0026gt; uPets = new ArrayList\u0026lt;\u0026gt;(); public User() { } public User(int id, String name, List\u0026lt;String\u0026gt; pets){ this.uId = id; this.uName = name; this.uPets.addAll(pets); }; //getters setters removed for brevity } User DAO stays more or less the same. You can include methods to fetch particular user from user id or name, I will leave that as an exercise for you.\n@Dao public interface UserDAO { @Insert(onConflict = REPLACE) void insertUser(User user); @Query(\u0026#34;SELECT * FROM User\u0026#34;) List\u0026lt;User\u0026gt; getUsers(); //include any methods to fetch specific user //@Query(\u0026#34;SELECT * FROM User\u0026#34;) } And our UserDB will also stay the same except small difference.\n@Database (entities = {User.class},version = 1) @TypeConverters({Converters.class}) public abstract class UserDB extends RoomDatabase { public abstract UserDAO userDAO(); } Noticed that @TypeConverters annotation we provided along with @Database annotation, this will be the class which will tell Room how to convert ArrayList object to one of SQLite data type. We will implement methods to convert ArrayList to String for storing it in DB and String back to ArrayList for getting back original User object.\nType Converter specifies additional type converters that Room can use. The TypeConverter is added to the scope of the element so if you put it on a class / interface, all methods / fields in that class will be able to use the converters.\nWithout further delay, we will see how our type converter looks in our case.\npublic class Converters { @TypeConverter public static ArrayList\u0026lt;String\u0026gt; fromString(String value) { Type listType = new TypeToken\u0026lt;ArrayList\u0026lt;String\u0026gt;\u0026gt;() {}.getType(); return new Gson().fromJson(value, listType); } @TypeConverter public static String fromArrayLisr(ArrayList\u0026lt;String\u0026gt; list) { Gson gson = new Gson(); String json = gson.toJson(list); return json; } } As you can see, we have 2 methods in TypeConverter.\npublic static String fromArrayLisr(ArrayList list) : This method takes our arraylist object as parameter and returns string representation for it so that it can be stored in Room Database. Very simple and easy way to convert any object to string is converting it into its JSON equivalent. Just creating Gson object and calling toJson method with our object as parameter is enough.\npublic static ArrayList fromString(String value) : While reading data back from Room Database, we get JSON form of our arraylist which we need to convert back. We will use Gson method fromJson by providing JSON string as parameter. But while converting back, we also need to provide the class of original object (in our case, arraylist), but providing arraylist is not enough here as Gson will not be able know what kind of list it has to form. That’s why we used Type to provide the type of list we want Gson to form for us from the JSON string.\nAnd that’s it, converter is ready to be used. We have mentioned this converter in UserDB class which will be automatically used by Room Database to convert arraylist to string and vice versa. I hope you found this article helpful, if yes, be sure to leave your comment. In next article, I will write about migrating current SQLite implemented using SQLiteHelper classes to Room Database.\nYou can find the sample here at GitHub.\nThis article was originally written on medium here\n","permalink":"http://localhost:1313/posts/room-android/","summary":"If you have been following Architectural components introduced in I/0 2017, you must already be familiar with the Room Persistence Library which provides you abstraction layer over SQLite to provide smooth database access and using SQLite with full potential. If you are not aware or don’t know how Room Database works, I would recommend reading this article which shows the very basic usage and implementation of Room Database in your android project.","title":"Storing Java objects other than primitive types in Room Database"}]